/*
 * (C) Copyright 2002-2006
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * (C) Copyright 2002
 * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
 * Marius Groeger <mgroeger@sysgo.de>
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

/*
 * To match the U-Boot user interface on ARM platforms to the U-Boot
 * standard (as on PPC platforms), some messages with debug character
 * are removed from the default U-Boot build.
 *
 * Define DEBUG here if you want additional info as shown below
 * printed upon startup:
 *
 * U-Boot code: 00F00000 -> 00F3C774  BSS: -> 00FC3274
 * IRQ Stack: 00ebff7c
 * FIQ Stack: 00ebef7c
 */

#include <common.h>
#include <command.h>
#include <malloc.h>
#include <devices.h>
#include <version.h>
#include <net.h>
#include <asm/io.h>
#include <movi.h>
#include <regs.h>
#include <serial.h>
#include <nand.h>
#include <onenand_uboot.h>

#ifdef CONFIG_GENERIC_MMC
#include <mmc.h>
#endif


#undef DEBUG

#ifdef CONFIG_DRIVER_SMC91111
#include "../drivers/net/smc91111.h"
#endif
#ifdef CONFIG_DRIVER_LAN91C96
#include "../drivers/net/lan91c96.h"
#endif

#include <s5pc110.h>

DECLARE_GLOBAL_DATA_PTR;

void nand_init (void);
void onenand_init(void);

ulong monitor_flash_len;

int check_flash_flag=1;

#ifdef CONFIG_HAS_DATAFLASH
extern int  AT91F_DataflashInit(void);
extern void dataflash_print_info(void);
#endif

#ifndef CONFIG_IDENT_STRING
#define CONFIG_IDENT_STRING ""
#endif

// U_BOOT_VERSION在uboot源代码中找不到，这个变量实际上是在Makefile中定义的U_BOOT_VERSION
// include/version_autogenerated.h文件中	#define U_BOOT_VERSION "U-Boot 1.3.4"
const char version_string[] =
	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")"CONFIG_IDENT_STRING;

#ifdef CONFIG_DRIVER_CS8900
extern int cs8900_get_enetaddr (uchar * addr);
#endif

#ifdef CONFIG_DRIVER_RTL8019
extern void rtl8019_get_enetaddr (uchar * addr);
#endif

#if defined(CONFIG_HARD_I2C) || \
    defined(CONFIG_SOFT_I2C)
#include <i2c.h>
#endif

/*
 * Begin and End of memory area for malloc(), and current "brk"
 */
static ulong mem_malloc_start = 0;
static ulong mem_malloc_end = 0;
static ulong mem_malloc_brk = 0;
// 告诉堆管理器自己所有管控的内存是从哪里开始的，在哪里结束
static void mem_malloc_init (ulong dest_addr)
{
	// malloc起始地址
	mem_malloc_start = dest_addr;
	// malloc结束地址
	mem_malloc_end = dest_addr + CFG_MALLOC_LEN;
	mem_malloc_brk = mem_malloc_start;
	// 把这段内存清零
	memset ((void *) mem_malloc_start, 0,
			mem_malloc_end - mem_malloc_start);
}

void *sbrk (ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
	ulong new = old + increment;

	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
		return (NULL);
	}
	mem_malloc_brk = new;

	return ((void *) old);
}

char *strmhz(char *buf, long hz)
{
	long l, n;
	long m;

	n = hz / 1000000L;
	l = sprintf (buf, "%ld", n);
	m = (hz % 1000000L) / 1000L;
	if (m != 0)
		sprintf (buf + l, ".%03ld", m);
	return (buf);
}


/************************************************************************
 * Coloured LED functionality
 ************************************************************************
 * May be supplied by boards if desired
 */
void __coloured_LED_init (void) {}
void coloured_LED_init (void)
	__attribute__((weak, alias("__coloured_LED_init")));
void  __red_LED_on (void) {}
void  red_LED_on (void)
	__attribute__((weak, alias("__red_LED_on")));
void  __red_LED_off(void) {}
void  red_LED_off(void)	     __attribute__((weak, alias("__red_LED_off")));
void  __green_LED_on(void) {}
void  green_LED_on(void) __attribute__((weak, alias("__green_LED_on")));
void  __green_LED_off(void) {}
void  green_LED_off(void)__attribute__((weak, alias("__green_LED_off")));
void  __yellow_LED_on(void) {}
void  yellow_LED_on(void)__attribute__((weak, alias("__yellow_LED_on")));
void  __yellow_LED_off(void) {}
void  yellow_LED_off(void)__attribute__((weak, alias("__yellow_LED_off")));

/************************************************************************
 * Init Utilities							*
 ************************************************************************
 * Some of this code should be moved into the core functions,
 * or dropped completely,
 * but let's get it working (again) first...
 */
// 初始化串口通信的波特率的
// 都是软件方面的设置
static int init_baudrate (void)
{
	char tmp[64];	/* long enough for environment variables */
	// getenv_r函数用来读取环境变量的值
	// 这里用getenv_r函数读取环境变量中"baudrate"的值(注意读取到的不是int型而是字符串类型)
	// 然后用simple_strtoul函数将字符串转成数字格式的波特率
	// getenv_r函数成功读取baudrate的值，则返回值>0；否则返回<0
	// baudrate初始化时的规则是: 先去环境变量中读取"baudrate"这个环境变量的值。如果读取成功则使用
	// 这个值作为环境变量，记录在gd->bd->bi_baudrate和gd->baudrate中；如果读取不成功则使用x210_sd.h
	// 中的CONFIG_BAUDRATE的值作为波特率。从这可以看出: 环境变量的优先级是很高的。
	// CONFIG_BAUDRATE这中宏定义的属于硬编码的，级别很低的。
	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
	gd->bd->bi_baudrate = gd->baudrate = (i > 0)
			? (int) simple_strtoul (tmp, NULL, 10)
			: CONFIG_BAUDRATE;

	return (0);
}
// 这个函数主要是控制GPF3_5寄存器
static void open_backlight(void)
{
	unsigned int reg;

	//open backlight. GPF3_5=1，设置为输出模式
	reg = readl(GPF3CON);
	reg = reg & ~(0xf<<20) | (0x1<<20);
	writel(reg,GPF3CON);

	reg = readl(GPF3PUD);
	reg = reg & ~(0x3<<10) | (0x2<<10);
	writel(reg,GPF3PUD);

	reg = readl(GPF3DAT);
	reg |= (0x1<<5);
	writel(reg,GPF3DAT);
}

/*
 * GPH0_2: LEFT
 */
static int check_menu_update_from_sd(void)
{
	unsigned int i;
	unsigned int reg;

	//GPH0_2
	reg = readl(GPH0CON);
	reg = reg & ~(0xf<<8) | (0x0<<8);
	writel(reg,GPH0CON);

	for(i=0;i<100;i++)
		udelay(500);

	reg = readl(GPH0DAT);
	reg = reg & (0x1<<2);

	if(reg)
		return 1;
	else //update mode
		return 0;
}

/*
 * GPC1_1: GPRS_PWR_EN
 * GPJ0_4: CDMAPWR
 * GPJ0_1: GSM_RST
 * GPJ0_6: GSM_ON_OFF
 */
static void open_gprs(void)
{
	unsigned int i;
	unsigned int reg;

	//step0: init gpio
	reg = readl(GPC1CON);
	reg = reg & ~(0xf<<4) | (0x1<<4);	//set GPC1_1 to output and enable pullup
	writel(reg,GPC1CON);
	reg = readl(GPC1PUD);
	reg = reg & ~(0x3<<2) | (0x2<<2);
	writel(reg,GPC1PUD);

	reg = readl(GPJ0CON);
	reg	= reg & ~(0xf<<4) | (0x1<<4);	//set GPJ0_1 to output and enable pullup
	writel(reg,GPJ0CON);
	reg = readl(GPJ0PUD);
	reg = reg & ~(0x3<<2) | (0x2<<2);
	writel(reg,GPJ0PUD);

	reg = readl(GPJ0CON);
	reg	= reg & ~(0xf<<16) | (0x1<<16);	//set GPJ0_4 to output and enable pullup
	writel(reg,GPJ0CON);
	reg = readl(GPJ0PUD);
	reg = reg & ~(0x3<<8) | (0x2<<8);
	writel(reg,GPJ0PUD);

	reg = readl(GPJ0CON);
	reg	= reg & ~(0xf<<24) | (0x1<<24);	//set GPJ0_6 to low level and enable pullup
	writel(reg,GPJ0CON);
	reg = readl(GPJ0PUD);
	reg = reg & ~(0x3<<12) | (0x2<<12);
	writel(reg,GPJ0PUD);

	reg = readl(GPJ0DAT);
	reg &= ~(0x1<<6);
	writel(reg,GPJ0DAT);

	//step1: disable reset
	reg = readl(GPJ0DAT);
	reg &= ~(0x1<<1);
	writel(reg,GPJ0DAT);

	//step2: enable GPRS power(4.2V to GPRS module)
	reg = readl(GPC1DAT);
	reg |= (0x1<<1);
	writel(reg,GPC1DAT);

	//step3: enable CDMAPWR(4.2V to GC864)
	reg = readl(GPJ0DAT);
	reg |= (0x1<<4);
	writel(reg,GPJ0DAT);

	for(i=0;i<100;i++)
		udelay(1000);

	//step4: power on GC864
	reg = readl(GPJ0DAT);
	reg |= (0x1<<6);
	writel(reg,GPJ0DAT);
	for(i=0;i<1000/*2000*/;i++)
		udelay(1000);
	reg &= ~(0x1<<6);
	writel(reg,GPJ0DAT);
}

// 函数用来串口输出显示uboot的logo
static int display_banner (void)
{
	// display_banner中使用printf函数向串口输出了version_string这个字符串。
	// 那么console_init_f并没有初始化好console怎么就可以printf了呢?
	// 通过追踪printf的实现，发现printf->puts，而puts函数中会判断当前uboot中console有没有被初始化好。
	// 如果console初始化好了则调用fputs完成串口发送；如果console尚未初始化好则会调用serial_puts(再
	// 调用serial_putc直接操作串口寄存器进行内容发送)。
	// 控制台也是通过串口输出，非控制台也是通过串口输出。究竟什么是控制台? 和不用控制台的区别? 实际上
	// 分析代码会发现，控制台就是一个用软件虚拟出来的设备，这个设备有一套专用的通信函数(发送、接收・・)
	// 控制台的通信函数最终会映射到硬件的通信函数中来实现。uboot中实际上控制台的通信函数是直接映射
	// 到硬件串口的通信函数中的，也就是uboot中用没用控制台并没有本质差别。
	// 但是在别的体系中，控制台的通信函数映射到硬件的通信函数时可以用软件来做一些中间优化，譬如说
	// 缓冲机制。(操作系统中控制台都使用了缓冲机制，所以有时候printf了内容但是屏幕上并没有看到输出
	// 信息，就是因为被缓冲了。我们输出的信息只是到了console的buffer中，buffer还没有被刷新到硬件输出
	// 设备上，尤其是在输出设备是LCD屏幕时)
	// 所以我们走的是printf->puts->serial_puts->serial_putc这条路。
	printf ("\n\n%s\n\n", version_string);
	// 只有在该文件前面定义了debug宏才能执行debug函数，而我们这个文件的前面没有定义debug宏
	debug ("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
	       _armboot_start, _bss_start, _bss_end);
#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
	debug("\t\bMalloc and Stack is above the U-Boot Code.\n");
#else
	debug("\t\bMalloc and Stack is below the U-Boot Code.\n");
#endif
#ifdef CONFIG_MODEM_SUPPORT
	debug ("Modem Support enabled\n");
#endif
#ifdef CONFIG_USE_IRQ
	debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
	debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif
	// 打开LCD背光
	// 注释掉这个也可以，主要原因是后面LCD操作的部分还会再做一遍的
	open_backlight();//lqm.
	//open_gprs();

	return (0);
}

/*
 * WARNING: this code looks "cleaner" than the PowerPC version, but
 * has the disadvantage that you either get nothing, or everything.
 * On PowerPC, you might see "DRAM: " before the system hangs - which
 * gives a simple yet clear indication which part of the
 * initialization if failing.
 */
static int display_dram_config (void)
{
	int i;

#ifdef DEBUG
	puts ("RAM Configuration:\n");

	for(i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
		printf ("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);
		print_size (gd->bd->bi_dram[i].size, "\n");
	}
#else
	ulong size = 0;
	// for循环是计算两片内存加起来一共有多大
	for (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
		size += gd->bd->bi_dram[i].size;
	}

	puts("DRAM:    ");
	// print_size计算size的大小在哪个级别上
	print_size(size, "\n");
	// 思考: 如何在uboot运行中得知uboot的DDR配置信息?
	// uboot中有一个命令叫bdinfo，这个命令可以打印gd->bd中记录的所有硬件相关的全局变量的值
	// 因此可以得知DDR的配置信息。
#endif

	return (0);
}

#ifndef CFG_NO_FLASH
static void display_flash_config (ulong size)
{
	puts ("Flash:  ");
	print_size (size, "\n");
}
#endif /* CFG_NO_FLASH */

#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
static int init_func_i2c (void)
{
	puts ("I2C:   ");
	i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
	puts ("ready\n");
	return (0);
}
#endif

#ifdef CONFIG_SKIP_RELOCATE_UBOOT
/*
 * This routine sets the relocation done flag, because even if
 * relocation is skipped, the flag is used by other generic code.
 */
static int reloc_init(void)
{
	gd->flags |= GD_FLG_RELOC;
	return 0;
}
#endif

/*
 * Breathe some life into the board...
 *
 * Initialize a serial port as console, and carry out some hardware
 * tests.
 *
 * The first part of initialization is running from Flash memory;
 * its main purpose is to initialize the RAM so that we
 * can relocate the monitor code to RAM.
 */

/*
 * All attempts to come up with a "common" initialization sequence
 * that works for all boards and architectures failed: some of the
 * requirements are just _too_ different. To get rid of the resulting
 * mess of board dependent #ifdef'ed code we now make the whole
 * initialization sequence configurable to the user.
 *
 * The requirements for any new initalization function is simple: it
 * receives a pointer to the "global data" structure as it's only
 * argument, and returns an integer return code, where 0 means
 * "continue" and != 0 means "fatal error, hang the system".
 */
// 这是一个函数类型
typedef int (init_fnc_t) (void);

int print_cpuinfo (void); /* test-only */

// 总结: init_sequence中都是板级的硬件初始化以及gd、gd->bd的数据结构(硬件有关的)的初始化
// 譬如: 网卡初始化、机器码(gd->bd->arch_number)、内核传参DDR地址(gd->bd->bi_boot_params)、
// Timer4初始化一次10ms、波特率设置(gd->bd->bi_baudrate)、console第一阶段初始化(gd->have_console
// 设置为1)、打印uboot的启动信息、打印CPU的时钟信息、检查并打印开发板名字、DDR配置信息初始化(gd->bd->bi_dram)、
// 打印DDR总容量

// 函数指针数组，数组中存储了很多个函数指针，这些指针指向的函数都是init_fnc_t类型
// 特征是接收参数是void类型，返回值是int。
// init_sequence定义时同时给了初始化，初始化的函数指针都是函数名。
// init_sequence中的这些函数都是board级别(CPU外部的，开发板内部的；想比start.S中的都是CPU内部的初始化)的各种硬件初始化
init_fnc_t *init_sequence[] = {
	cpu_init,		/* basic cpu dependent setup cpu内部的初始化，在start.S中已经初始化了，所以这里面是空的*/
#if defined(CONFIG_SKIP_RELOCATE_UBOOT)
	reloc_init,		/* Set the relocation done flag, must
				   do this AFTER cpu_init(), but as soon
				   as possible */
#endif
	board_init,		/* basic board dependent setup */
	interrupt_init,		/* set up exceptions */
	// 看名字知道是和环境变量有关的初始化
	// 为什么有很多env_init函数，主要原因是uboot支持各种不同的启动介质(譬如norflash、nandfalsh、
	// inand、SD卡・・・)，我们一般从哪里启动就会把环境变量env放到哪里。而各种介质存取操作env的
	// 方法都是不一样的。因此uboot支持了各种不同介质中env的操作方法。所以有好多个env_xxx开头的.c文件。
	// 实际使用的是哪一个要根据自己开发板使用的存储介质来决定(这些env_xxx.c同时只有1个会起作用，其他
	// 是不能进去的，通过x210_sd.h中配置的宏来决定谁被包含的)，对于x210来说，我们应该使用的env_movi.c中的函数
	env_init,		/* initialize environment */
	init_baudrate,		/* initialze baudrate settings */
	// 初始化串口。(疑问: start.S中调用的lowlevel_init.S中已经使用汇编初始化串口了，这里怎么又初始化?
	// 这两个初始化是重复的还是各自有不同?)，答: 这个函数其实什么都没做。
	// 因为在汇编阶段串口已经被初始化过了，因此这里就不在进行硬件寄存器的初始化了。
	serial_init,		/* serial communications setup */
	console_init_f,		/* stage 1 init of console */
	display_banner,		/* say that we are here */
#if defined(CONFIG_DISPLAY_CPUINFO)
	print_cpuinfo,		/* display cpu info (and speed) */
#endif
#if defined(CONFIG_DISPLAY_BOARDINFO)
	checkboard,		/* display board info */
#endif
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
	// 这个函数实际上没有被执行，X210的uboot中并没有使用I2C。如果将来我们的开发板要扩展I2C来
	// 接外接硬件，则在x210_sd.h中配置相应的宏即可开启
	init_func_i2c,
#endif
	dram_init,		/* configure available RAM banks */
	display_dram_config,
	NULL,
};
// 这个450行还不是全部，因为里面还调用了别的函数
// 这个函数组成uboot启动的第二阶段
// 宏观分析: uboot第二阶段应该做什么
// 概括来讲，uboot第一阶段主要就是初始化了SOC内部的一些部件(譬如看门狗、时钟)，然后初始化DDR并且完成重定位
// 有宏观分析来讲，uboot的第二阶段就是要初始化剩下的还没被初始化的硬件。主要是SOC外部硬件(譬如flash、iNand、网卡芯片)
// 还有uboot本身的一些东西(uboot的命令、环境变量等)。最终初始化完必要的东西后进入到uboot的命令行准备接受命令。
// uboot启动后自动运行打印出很多信息(这些信息就是uboot在第一和第二阶段不断初始化时，打印出来的信息)。
// 然后uboot进入了倒数bootdelay秒，然后执行bootcmd对应的启动命令。
// 如果用户没有干涉则会执行bootcmd进入自动启动内核流程(uboot就死掉了)；此时用户可以通过按下回车键
// 打断uboot的自动启动进入uboot的命令行下。然后uboot就一直工作在命令行下。uboot的命令行就是死循环，
// 循环体内不断重复: 接收命令、解析命令、执行命令。这就是uboot的最终归宿。
void start_armboot (void)
{
	// init_fnc_ptr是一个二重函数指针，二重指针作用: 
	// 有两个，其中一个用来指向一重指针；另一个是用来指向指针数组
	// 因此这里的init_fnc_ptr可以用来指向一个函数指针数组
	init_fnc_t **init_fnc_ptr;
	char *s;
	int mmc_exist = 0;
#if !defined(CFG_NO_FLASH) || defined (CONFIG_VFD) || defined(CONFIG_LCD)
	ulong size;
#endif

#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
	unsigned long addr;
#endif

#if defined(CONFIG_BOOT_MOVINAND)
	uint *magic = (uint *) (PHYS_SDRAM_1);
#endif

	/* Pointer is writable since we allocated a register for it */
#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
	ulong gd_base;		// gd在DDR中内存分配的起始地址
	// CFG_UBOOT_BASE-XXX(长度为uboot的实际长度)这是存放uboot的地方
	// 堆区长度为CFG_MALLOC_LEN，实际大约是912KB
	// 栈区长度为CFG_STACK_SIZE，实际是512KB
	// gd结构体长度sizeof(gd_t)，实际大约是36字节
	// bd结构体长度sizeof(bd_t)，实际大约是44字节
	// gd_base地址为600KB左右。
	gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t);
#ifdef CONFIG_USE_IRQ
	gd_base -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
#endif	// CONFIG_USE_IRQ
	// gd里的这些全局变量并没有分配内存，我们在使用gd之前要给他分配内存，否则gd也只是一个野指针而已
	// gd和bd需要内存，内存当前没有被人管理(因为没有操作系统统一管理内存)，大片的DDR内存散放着可以随意使用(
	// 只要使用内存地址直接去访问内存即可)。但是因为uboot中后续很多操作还需要大片的连着的内存块。
	// 因此这里使用内存要本着够用就好，紧凑排布的原则。所以我们在uboot中需要有一个整体规划。
	gd = (gd_t*)gd_base;	// gd_base强制类型转换为gd_t*，gd指向了这段内存空间
#else	// CONFIG_MEMORY_UPPER_CODE
	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
#endif	// CONFIG_MEMORY_UPPER_CODE

	/* compiler optimization barrier needed for GCC >= 3.4 */
	// 内存间隔: 为了防止高版本的gcc的优化造成错误
	__asm__ __volatile__("": : :"memory");	// __asm__是C语言内嵌汇编
	// 把gd全局变量全部清零
	memset ((void*)gd, 0, sizeof (gd_t));
	// (char*)gd这个是gd_base的基地址；sizeof(bd_t)是bd的大小
	// 指针的运算是和指针的种类有关系的
	// 如果指针的类型是char*，那么减一就是减一；如果指针对的类型是int*，那么减一就是减4*1
	gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
	memset (gd->bd, 0, sizeof (bd_t));

	monitor_flash_len = _bss_start - _armboot_start;
	// init_fnc_ptr是一个二重函数指针，可以指向init_sequence这个函数指针数组
	// *init_fnc_ptr相当于判断*init_fnc_ptr所指向的函数的返回值是否等于NULL(相当于*init_fnc_ptr != NULL)
	// *init_fnc_ptr = NULL，那么for循环终止
	// ++init_fnc_ptr是指针++，刚好走4个字节
	// 用for循环肯定想要去遍历这个函数指针数组(遍历的目的也是依次执行这个函数指针数组中的所有函数)
	// 有两种遍历方法:
	// 第一种也是最常用的一种，用下标去遍历，用数组元素个数来截止。
	// 第二种不常用但是也可以，在数组的有效元素末尾放一个标志，依次遍历到标志处即可截止(有点像字符串的思路)。
	// 我们这里使用了第二种思路，因为数组中存的全都是函数指针，因此我们选择了NULL来作为标志。
	// 我们遍历时从开头依次进行，直到看到NULL标志截止。这种方法的优势是不用事先考虑数组有多少个元素。
	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {	
		// (*init_fnc_ptr)()是使用函数指针的方法来调用函数
		// init_fnc_ptr的这些函数的返回值定义方式一样的，正确时返回0，不正确时返回-1，
		// 如果遍历中有一个函数返回值不等于0则hang()挂起
		if ((*init_fnc_ptr)() != 0) {
			// 从分析hang函数可知:uboot启动过程中初始化板级硬件时不能出任何错误，
			// 只要有一个错误整个启动就终止，除了重启开发板没有任何办法
			// 因为uboot启动时初始化是很重要的，如果uboot这里出现了问题，证明你的代码或硬件有问题
			hang ();				
		}
	}
// CFG_NO_FLASH这个宏定义如果在x210_sd.h中定义了，编译出错，说明代码移植的不好，那个文件的包含没有被这个宏控制。
// 于是乎移植的人就直接放这没管。
// 虽然nandflash和norflash都是flash，但是一般nandflash会称为nand而不是flash，一般将flash都是指的norflash
#ifndef CFG_NO_FLASH
	/* configure available FLASH banks */
	size = flash_init ();		// 执行的是开发板中对应的NorFlash初始化
	display_flash_config (size);
#endif /* CFG_NO_FLASH */

// 虚拟显示有关，这个CONFIG_VFD和CONFIG_LCD是uboot中自带的LCD显示的软件架构。但是实际上我们用LCD而没有使用uboot中设置
// 的这套软件架构，我们自己在后面添加了一个LC显示的部分。
#ifdef CONFIG_VFD
#	ifndef PAGE_SIZE
#	  define PAGE_SIZE 4096
#	endif
	/*
	 * reserve memory for VFD display (always full pages)
	 */
	/* bss_end is defined in the board-specific linker script */
	addr = (_bss_end + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
	size = vfd_setmem (addr);
	gd->fb_base = addr;
#endif /* CONFIG_VFD */

#ifdef CONFIG_LCD
	/* board init may have inited fb_base */
	if (!gd->fb_base) {
#		ifndef PAGE_SIZE
#		  define PAGE_SIZE 4096
#		endif
		/*
		 * reserve memory for LCD display (always full pages)
		 */
		/* bss_end is defined in the board-specific linker script */
		addr = (_bss_end + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
		size = lcd_setmem (addr);
		gd->fb_base = addr;
	}
#endif /* CONFIG_LCD */

	/* armboot_start is defined in the board-specific linker script */
#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
	// mem_malloc_init函数用来初始化uboot的堆管理器(一坨malloc代码)
	// uboot中自己维护了一段堆内存，肯定自己就有一套代码来管理这个堆内存。
	// 有了这些东西uboot中你也可以malloc、free这套机制来申请内存和释放内存。
	// 我们在DDR内存中给堆预留了896KB的内存。
	mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE);
#else
	mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
#endif

//******************************//
// Board Specific
// #if defined(CONFIG_SMDKXXXX)
// 意思是三星用一套uboot同时满足了好多个系列型号的开发板，然后在这里把不同开发板自己
// 独有的一些初始化写到了这里。用#if条件编译配合CONFIG_XXX宏来选定特定的开发板。
//******************************//

#if defined(CONFIG_SMDK6410)
	#if defined(CONFIG_GENERIC_MMC)
	puts ("SD/MMC:  ");
	mmc_exist = mmc_initialize(gd->bd);
	if (mmc_exist != 0)
	{
		puts ("0 MB\n");
	}
	#else
	#if defined(CONFIG_MMC)
	puts("SD/MMC:  ");

	if (INF_REG3_REG == 0)
		movi_ch = 0;
	else
		movi_ch = 1;

	movi_set_capacity();
	movi_init();
	movi_set_ofs(MOVI_TOTAL_BLKCNT);
	#endif
	#endif

	if (INF_REG3_REG == BOOT_ONENAND) {
	#if defined(CONFIG_CMD_ONENAND)
		puts("OneNAND: ");
		onenand_init();
	#endif
		/*setenv("bootcmd", "onenand read c0008000 80000 380000;bootm c0008000");*/
	} else {
		puts("NAND:    ");
		nand_init();

		if (INF_REG3_REG == 0 || INF_REG3_REG == 7)
			setenv("bootcmd", "movi read kernel c0008000;movi read rootfs c0800000;bootm c0008000");
		else
			setenv("bootcmd", "nand read c0008000 80000 380000;bootm c0008000");
	}
#endif	/* CONFIG_SMDK6410 */

#if defined(CONFIG_SMDKC100)

	#if defined(CONFIG_GENERIC_MMC)
		puts ("SD/MMC:  ");
		mmc_exist = mmc_initialize(gd->bd);
		if (mmc_exist != 0)
		{
			puts ("0 MB\n");
		}
	#endif

	#if defined(CONFIG_CMD_ONENAND)
		puts("OneNAND: ");
		onenand_init();
	#endif

	#if defined(CONFIG_CMD_NAND)
		puts("NAND:    ");
		nand_init();
	#endif

#endif /* CONFIG_SMDKC100 */

#if defined(CONFIG_X210)

	#if defined(CONFIG_GENERIC_MMC)
		puts ("SD/MMC:  ");
		// mmc_initialize是MMC相关的一些基础的初始化，其实就是用来初始化SOC内部的SD/MMC控制器的。
		mmc_exist = mmc_initialize(gd->bd);
		// mmc_initialize返回值不等于，证明初始化失败了。则打印0 MB
		if (mmc_exist != 0)
		{
			puts ("0 MB\n");
#ifdef CONFIG_CHECK_X210CV3
			check_flash_flag=0;//check inand error!
#endif
		}
#ifdef CONFIG_CHECK_X210CV3
		else
		{
			check_flash_flag=1;//check inand ok! 
		}
#endif
	#endif

	#if defined(CONFIG_MTD_ONENAND)
		puts("OneNAND: ");
		onenand_init();
		/*setenv("bootcmd", "onenand read c0008000 80000 380000;bootm c0008000");*/
	#else
		//puts("OneNAND: (FSR layer enabled)\n");
	#endif

	#if defined(CONFIG_CMD_NAND)
		puts("NAND:    ");
		nand_init();
	#endif

#endif /* CONFIG_X210 */

#if defined(CONFIG_SMDK6440)
	#if defined(CONFIG_GENERIC_MMC)
	puts ("SD/MMC:  ");
	mmc_exist = mmc_initialize(gd->bd);
	if (mmc_exist != 0)
	{
		puts ("0 MB\n");
	}
	#else
	#if defined(CONFIG_MMC)
	if (INF_REG3_REG == 1) {	/* eMMC_4.3 */
		puts("eMMC:    ");
		movi_ch = 1;
		movi_emmc = 1;

		movi_init();
		movi_set_ofs(0);
	} else if (INF_REG3_REG == 7 || INF_REG3_REG == 0) {	/* SD/MMC */
		if (INF_REG3_REG & 0x1)
			movi_ch = 1;
		else
			movi_ch = 0;

		puts("SD/MMC:  ");

		movi_set_capacity();
		movi_init();
		movi_set_ofs(MOVI_TOTAL_BLKCNT);

	} else {

	}
	#endif
	#endif

	if (INF_REG3_REG == 2) {
			/* N/A */
	} else {
		puts("NAND:    ");
		nand_init();
		//setenv("bootcmd", "nand read c0008000 80000 380000;bootm c0008000");
	}
#endif /* CONFIG_SMDK6440 */

#if defined(CONFIG_SMDK6430)
	#if defined(CONFIG_GENERIC_MMC)
	puts ("SD/MMC:  ");
	mmc_exist = mmc_initialize(gd->bd);
	if (mmc_exist != 0)
	{
		puts ("0 MB\n");
	}
	#else
	#if defined(CONFIG_MMC)
	puts("SD/MMC:  ");

	if (INF_REG3_REG == 0)
		movi_ch = 0;
	else
		movi_ch = 1;

	movi_set_capacity();
	movi_init();
	movi_set_ofs(MOVI_TOTAL_BLKCNT);
	#endif
	#endif

	if (INF_REG3_REG == BOOT_ONENAND) {
	#if defined(CONFIG_CMD_ONENAND)
		puts("OneNAND: ");
		onenand_init();
	#endif
		/*setenv("bootcmd", "onenand read c0008000 80000 380000;bootm c0008000");*/
	} else if (INF_REG3_REG == BOOT_NAND) {
		puts("NAND:    ");
		nand_init();
	} else {
	}

	if (INF_REG3_REG == 0 || INF_REG3_REG == 7)
		setenv("bootcmd", "movi read kernel c0008000;movi read rootfs c0800000;bootm c0008000");
	else
		setenv("bootcmd", "nand read c0008000 80000 380000;bootm c0008000");
#endif	/* CONFIG_SMDK6430 */

#if defined(CONFIG_SMDK6442)
	#if defined(CONFIG_GENERIC_MMC)
	puts ("SD/MMC:  ");
	mmc_exist = mmc_initialize(gd->bd);
	if (mmc_exist != 0)
	{
		puts ("0 MB\n");
	}
	#else
	#if defined(CONFIG_MMC)
	puts("SD/MMC:  ");

	movi_set_capacity();
	movi_init();
	movi_set_ofs(MOVI_TOTAL_BLKCNT);

	#endif
	#endif

	#if defined(CONFIG_CMD_ONENAND)
	if (INF_REG3_REG == BOOT_ONENAND) {
		puts("OneNAND: ");
		onenand_init();
		}
	#endif

#endif	/* CONFIG_SMDK6442 */

#if defined(CONFIG_SMDK2416) || defined(CONFIG_SMDK2450)
	#if defined(CONFIG_NAND)
	puts("NAND:    ");
	nand_init();
	#endif

	#if defined(CONFIG_ONENAND)
	puts("OneNAND: ");
	onenand_init();
	#endif

	#if defined(CONFIG_BOOT_MOVINAND)
	puts("SD/MMC:  ");

	if ((0x24564236 == magic[0]) && (0x20764316 == magic[1])) {
		printf("Boot up for burning\n");
	} else {
			movi_init();
			movi_set_ofs(MOVI_TOTAL_BLKCNT);
	}
	#endif
#endif	/* CONFIG_SMDK2416 CONFIG_SMDK2450 */

// DATAFLASH是SPI的Flash，最大也就是2-3M，在单片机中需要小容量存储时使用DATAFLASH
#ifdef CONFIG_HAS_DATAFLASH
	AT91F_DataflashInit();
	dataflash_print_info();
#endif

	/* initialize environment */
	// 这个函数才是将环境变量从SD卡读取到DDR中，将环境变量从SD卡到DDR中的重定位。
	// 重定位之后需要环境变量时才可以从DDR中去取，重定位之前如果要使用环境变量只能从SD卡中去读取。
	env_relocate ();

#ifdef CONFIG_VFD
	/* must do this after the framebuffer is allocated */
	drv_vfd_init();
#endif /* CONFIG_VFD */

#ifdef CONFIG_SERIAL_MULTI
	serial_initialize();
#endif

	/* IP Address */
// 开发板的IP地址是在gd->bd中维护的，来源于环境变量ipaddr
// IP地址由4个0~255之间的数字组成，因此一个IP地址在程序中最简单的存储方法就是一个unsigned int。
// 但是人类容易看懂的并不是这种类型，而是点分十进制类型(192.168.1.2)。这两种类型可以互相转换。
	gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");

	/* MAC Address */
	{
		int i;
		ulong reg;
		char *s, *e;
		char tmp[64];

		i = getenv_r ("ethaddr", tmp, sizeof (tmp));
		// 这里处理的s用的就是tmp中的，而不是DDR中的环境变量
		// 这样处理的好处是，没有动DDR中的环境变量，省着破坏DDR中的环境变量
		s = (i > 0) ? tmp : NULL;		// s = tmp; tmp中的内容是ethaddr

		for (reg = 0; reg < 6; ++reg) {
			// simple_strtoul函数的参数:cp指向字符串的开始，endup指向分析的字符串末尾的位置，
			// base为要用的基数(进制数)，'0x'表示16进制，'0'表示8进制，其他都认定为10进制                    
			gd->bd->bi_enetaddr[reg] = s ? simple_strtoul (s, &e, 16) : 0;
			if (s)
				s = (*e) ? e + 1 : e;
		}

#ifdef CONFIG_HAS_ETH1
		i = getenv_r ("eth1addr", tmp, sizeof (tmp));
		s = (i > 0) ? tmp : NULL;

		for (reg = 0; reg < 6; ++reg) {
			gd->bd->bi_enet1addr[reg] = s ? simple_strtoul (s, &e, 16) : 0;
			if (s)
				s = (*e) ? e + 1 : e;
		}
#endif
	}

// 看名字就是设备初始化。这里的设备指的就是开发板上的硬件设备
// 放在这里初始化的设备都是驱动设备，这个函数本来就是从驱动框架中衍生出来的。
// uboot中很多设备的驱动是直接移植Linux内核的(譬如网卡、SD卡)，Linux内核中的
// 驱动都有相应的设备初始化函数。Linux内核在启动过程中就有一个devices_init(名字
// 不一定完全对，但是差不多)，作用就是集中执行各种硬件驱动的init函数。
// uboot的这个函数其实就是从Linux内核中移植过来的，它的作用也是去执行所有的从
// Linux内核中继承来的那些硬件驱动的初始化函数。
	devices_init ();	/* get the devices list going. */

#ifdef CONFIG_CMC_PU2
	load_sernum_ethaddr ();
#endif /* CONFIG_CMC_PU2 */
	// 跳转表，本身是一个函数指针数组，里面记录了很多函数的函数名。看这阵势是要实现一个函数指针
	// 到具体函数的映射关系，将来通过跳转表中的函数指针就可以执行具体的函数。这个其实就是在用
	// C语言实现面向对象编程。在Linux内核中有很多这种技巧。
	jumptable_init ();
#if !defined(CONFIG_SMDK6442)
// 第二阶段初始化才进行了实质性工作
	console_init_r ();	/* fully init console as a device */
#endif

#if defined(CONFIG_MISC_INIT_R)
	/* miscellaneous platform dependent initialisations */
	misc_init_r ();
#endif

	/* enable exceptions 中断初始化代码*/
// 这里指的是cpsr中总中断标志位的使能。
// 因为我们uboot中没有使用中断，因此没有定义CONFIG_USE_IRQ宏，因此我们这里这个函数是个空壳子。
// uboot中经常出现一种情况就是根据一个宏是否定义了来条件编译决定是否调用一个函数内部的代码。
// uboot中有2种解决方案来处理这种情况: 方案一: 在调用函数处使用条件编译，然后函数体实际完全提供
// 代码。方案二: 在调用函数处直接调用，然后在函数体处提供2个函数体，一个是有实体的一个是空壳子，
// 用宏条件编译来解决实际编译时编译哪个函数。
	enable_interrupts ();

	/* Perform network card initialisation if necessary */
#ifdef CONFIG_DRIVER_TI_EMAC
extern void dm644x_eth_set_mac_addr (const u_int8_t *addr);
	if (getenv ("ethaddr")) {
		dm644x_eth_set_mac_addr(gd->bd->bi_enetaddr);
	}
#endif

// CS8900实际上是网卡，我们没有用这个网卡，我们实际用的是DM9000
#ifdef CONFIG_DRIVER_CS8900
	cs8900_get_enetaddr (gd->bd->bi_enetaddr);
#endif

#if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96)
	if (getenv ("ethaddr")) {
		smc_set_mac_addr(gd->bd->bi_enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

// loadaddr和bootfile这两个环境变量都是内核启动有关的，在启动Linux内核时会参考这两个环境变量的值。
	/* Initialize from environment */
	if ((s = getenv ("loadaddr")) != NULL) {
		load_addr = simple_strtoul (s, NULL, 16);
	}
#if defined(CONFIG_CMD_NET)
	if ((s = getenv ("bootfile")) != NULL) {
		copy_filename (BootFile, s, sizeof (BootFile));
	}
#endif

#ifdef BOARD_LATE_INIT
// 这个函数是开发板级别的一些初始化里比较晚的了，这就是晚期初始化。
// 所以晚期就是前面该初始化的都初始化过了，剩下的一些必须放在后面初始化的就在这里了。
// 侧面说明了开发板级别的硬件软件初始化告一段落了。
	board_late_init ();
#endif
#if defined(CONFIG_CMD_NET)
#if defined(CONFIG_NET_MULTI)
	puts ("Net:   ");
#endif
// 看名字应该是网卡相关的初始化。
// 这是不是SOC与网卡芯片连接时SOC这边的初始化，而是网卡芯片本身的一些初始化。
// 对于X210(DM9000)来说，这个函数是空的。X210的网卡初始化在board_init函数中，网卡芯片的初始化在驱动中。
	eth_initialize(gd->bd);
#if defined(CONFIG_RESET_PHY_R)
	debug ("Reset Ethernet PHY\n");
	reset_phy();
#endif
#endif

#if defined(CONFIG_CMD_IDE)
	puts("IDE:   ");
	ide_init();
#endif

/****************lxg added 九鼎工程师添加的 **************/
#ifdef CONFIG_MPAD
	extern int x210_preboot_init(void);
// 真正的初始化LCD系统并且显示logo是这个函数，这个函数纯粹是九鼎在移植时添加的。
// 如果我们自己移植uboot可以考虑自己去添加
	x210_preboot_init();
// 解决新版本开发板X210BV3S的logo显示问题
// 用旧版本的uboot.bin下载到新版本开发板中，发现能工作，但是屏幕logo显示不正常(屏幕下面有一条显示
// 不正常的，然后logo是显示出来的但是不在屏幕正中间)。
// 原因分析: 主要原因新版开发板LCD屏幕的分辨率是1024*600而旧版分辨率是800*480，所以旧版本的uboot在
// 新版开发板上运行时，就会造成屏幕填充不满(现象就是有一排显示不正常的)，还会造成显示内容位置偏移，
// 本来在中间结果偏左了。
// 解决方案: 很简单，在uboot中将LCD的参数部分，分辨率改成1024*600即可。
#endif
/****************end**********************/

	/* check menukey to update from sd */
// uboot启动的最后阶段设计了一个自动更新的功能。就是: 我们可以将要升级的镜像放到SD卡的固定目录中，
// 然后开机时在uboot启动的最后阶段检查升级标志(是一个按键。按键中标志为"LEFT"的那个按键，这个按键
// 如果按下则表示update mode，如果启动时未按下表示boot mode)。如果进入update mode则uboot会自动从
// SD卡中读取镜像文件然后烧录到iNand中；
// 这种机制能够帮助我们快速烧录系统，常用于量产时用SD卡进行系统烧录部署。
	extern void update_all(void);
	if(check_menu_update_from_sd()==0)//update mode
	{
		puts ("[LEFT DOWN] update mode\n");
		run_command("fdisk -c 0",0);
		update_all();
	}
	else
		puts ("[LEFT UP] boot mode\n");

	/* main_loop() can return to retry autoboot, if so just run it again. */
	// uboot的最终归宿就是这个死循环，不断的接收命令，解析命令，执行命令
	for (;;) {
		// 死循环的循环体就是main_loop
		// main_loop函数执行一遍，就是获取命令，解析命令，执行命令
		main_loop ();
	}

	/* NOTREACHED - no way out of command loop except booting */
}

void hang (void)
{
	puts ("### ERROR ### Please RESET the board ###\n");
	// 死循环
	for (;;);
}

#ifdef CONFIG_MODEM_SUPPORT
static inline void mdm_readline(char *buf, int bufsiz);

/* called from main loop (common/main.c) */
extern void  dbg(const char *fmt, ...);
int mdm_init (void)
{
	char env_str[16];
	char *init_str;
	int i;
	extern char console_buffer[];
	extern void enable_putc(void);
	extern int hwflow_onoff(int);

	enable_putc(); /* enable serial_putc() */

#ifdef CONFIG_HWFLOW
	init_str = getenv("mdm_flow_control");
	if (init_str && (strcmp(init_str, "rts/cts") == 0))
		hwflow_onoff (1);
	else
		hwflow_onoff(-1);
#endif

	for (i = 1;;i++) {
		sprintf(env_str, "mdm_init%d", i);
		if ((init_str = getenv(env_str)) != NULL) {
			serial_puts(init_str);
			serial_puts("\n");
			for(;;) {
				mdm_readline(console_buffer, CFG_CBSIZE);
				dbg("ini%d: [%s]", i, console_buffer);

				if ((strcmp(console_buffer, "OK") == 0) ||
					(strcmp(console_buffer, "ERROR") == 0)) {
					dbg("ini%d: cmd done", i);
					break;
				} else /* in case we are originating call ... */
					if (strncmp(console_buffer, "CONNECT", 7) == 0) {
						dbg("ini%d: connect", i);
						return 0;
					}
			}
		} else
			break; /* no init string - stop modem init */

		udelay(100000);
	}

	udelay(100000);

	/* final stage - wait for connect */
	for(;i > 1;) { /* if 'i' > 1 - wait for connection
				  message from modem */
		mdm_readline(console_buffer, CFG_CBSIZE);
		dbg("ini_f: [%s]", console_buffer);
		if (strncmp(console_buffer, "CONNECT", 7) == 0) {
			dbg("ini_f: connected");
			return 0;
		}
	}

	return 0;
}

/* 'inline' - We have to do it fast */
static inline void mdm_readline(char *buf, int bufsiz)
{
	char c;
	char *p;
	int n;

	n = 0;
	p = buf;
	for(;;) {
		c = serial_getc();

		/*		dbg("(%c)", c); */

		switch(c) {
		case '\r':
			break;
		case '\n':
			*p = '\0';
			return;

		default:
			if(n++ > bufsiz) {
				*p = '\0';
				return; /* sanity check */
			}
			*p = c;
			p++;
			break;
		}
	}
}
#endif	/* CONFIG_MODEM_SUPPORT */
